#pragma once

#include "RobotAI_Interface.h"



class RobotAI:public RobotAI_Interface
{
protected:
	//TODO:可以在这里添加你自己的成员变量
	int MyCar = 0;
	const int color = 255;
	enum{
		AFV_Esaw,
		AFV_Prism,
		AFV_WT_Machinegun
	};
public:

	//************************************************
	//这一段函数声明别乱动啊，否则机甲抛锚了别怪我

	RobotAI();
	virtual ~RobotAI();



	//-----------------------------------------------------
	//1.必须完成的战斗核心
	//-----------------------------------------------------

	//帧操纵函数
	//功能：在每一帧被调用，完成你的机甲在这一帧的动作决策
	//参数：order	...	机甲操纵指令，你在函数体中给它赋值以操纵机甲在这一帧的行为
	//		info	...	战场信息
	//		myID	... 自己机甲在info中robot数组对应的下标
	//		(这几个参数的详细说明在开发手册可以找到，你也可以在RobotAIstruct.h中直接找到它们的代码)
	virtual void Update(RobotAI_Order& order,const RobotAI_BattlefieldInformation& info,int myID);



	//挑选装备函数
	//功能：在战斗开始时为你的机甲选择合适的武器炮塔和引擎载具
	//参数：weapon	...	代表你选择的武器，在函数体中给它赋值
	//		engine	...	代表你选择的引擎，在函数体中给它赋值
	//tip:	括号里的参数是枚举类型 weapontypename 或 enginetypename
	//		开发文档中有详细说明，你也可以在RobotAIstruct.h中直接找到它们的代码
	//tip:	最后一个bool是没用的。。那是一个退化的器官
	virtual void ChooseArmor(weapontypename& weapon,enginetypename& engine,bool);


	//-----------------------------------------------------






	//-----------------------------------------------------
	//2.个性信息
	//-----------------------------------------------------

	//返回你的机甲的名字
	virtual string GetName();

	//返回机甲制作人或团队的名字
	virtual string GetAuthor();



	//返回一个(-255,255)之间的机甲武器炮塔的颜色偏移值（红、绿、蓝）
	//你可以在flash客户端的参数预览中预览颜色搭配的效果
	virtual int GetWeaponRed();
	virtual int GetWeaponGreen();
	virtual int GetWeaponBlue();

	//返回一个(-255,255)之间的机甲引擎载具的颜色偏移值（红、绿、蓝）
	//你可以在flash客户端的参数预览中预览颜色搭配的效果
	virtual int GetEngineRed();
	virtual int GetEngineGreen();
	virtual int GetEngineBlue();

	//-----------------------------------------------------




	//-----------------------------------------------------
	//3.用不用随你的触发函数
	//-----------------------------------------------------


	//一场战斗开始时被调用，可能可以用来初始化
	//参数：info	...	战场信息
	//		myID	... 自己机甲在info中robot数组对应的下标
	virtual void onBattleStart(const RobotAI_BattlefieldInformation& info,int myID);



	//一场战斗结束时被调用，可能可以用来析构你动态分配的内存空间（如果你用了的话）
	//参数：info	...	战场信息
	//		myID	... 自己机甲在info中robot数组对应的下标
	virtual void onBattleEnd(const RobotAI_BattlefieldInformation& info,int myID);


	//有机甲开火时被调用
	//参数：fireID	... 开火的机甲下标
	virtual void onSomeoneFire(int);


	//被子弹击中时被调用
	//参数：btn	...	击中你的子弹种类（枚举类型）
	virtual void onHit(int,bullettypename);

	//-------------------------------------------------------------



	//***************************************************************



	//TODO:可以在这里添加你自己的函数声明,并在RobotAI.cpp中编写相应的函数定义

	bool HaveBarrier(const RobotAI_BattlefieldInformation& info,const int myID,const int ArID);//判断和地方之间是否有障碍物
	int GetNearetBul(RobotAI_Order& order, const RobotAI_BattlefieldInformation& info, const int myID);//获取最近的子弹下标

	/*<<<<<<<对每个机甲适应的部分(多个重载函数时，最下方为适应函数)*/
	void onTag1(RobotAI_Order& order, const RobotAI_BattlefieldInformation& info, const int myID);//瞄准函数（不带预判）
	double onTagRota(const RobotAI_BattlefieldInformation& info, const int myID);//返回武器夹角和与对面方向的夹角差

	void onMove1(RobotAI_Order& order, const RobotAI_BattlefieldInformation& info, const int myID,const Circle circle_tag);//移动到(circle_tag.x,circle_tag.y）的函数
	void onMove1(RobotAI_Order& order, const RobotAI_BattlefieldInformation& info, const int myID, const double x_tag, const double y_tag);//移动到(x_tag,y_tag)的函数
	void onMove1(RobotAI_Order& order, const RobotAI_BattlefieldInformation& info, const int myID, const double rota_tag);//向rota_tag（角度）移动
	
	void onFire1(RobotAI_Order& order, const RobotAI_BattlefieldInformation& info, const int myID);//开火函数

	bool onDodge(RobotAI_Order& order, const RobotAI_BattlefieldInformation& info, const int myID, const RobotAI_BulletInformation& bullet);//躲闪函数

	/*对每个机甲适应的部分>>>>>>>*/

	bool WillNotHit(const RobotAI_BulletInformation& bullet, const RobotAI_RobotInformation& rotinfo);//判断子弹绝对不会打到
	bool WillHit(const RobotAI_BulletInformation& bullet, const RobotAI_RobotInformation& rotinfo);
	double abvalue(double x);
	double pointdis(const Circle a1, const Circle a2, const Circle a3);
	double pointdis(double x1, double y1, double x2, double y2, double x3, double y3); 
	double pointdis(double k,double x1,double y1,double x3, double y3);
	double dis(double x1, double y1, double x2, double y2);
	double dis(const Circle& a, const Circle& b);
	
};